package cmds

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/codecrafters-io/redis-starter-go/app/resp"
	"github.com/codecrafters-io/redis-starter-go/app/storage"
)

var errTooSmallStreamId = errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
var errStreamIdZero = errors.New("ERR The ID specified in XADD must be greater than 0-0")
var errStreamIdFormat = errors.New("ERR the ID specified in XADD must be in  milliseconds-sqnumber format")

type XaddHandler struct {
	storage *storage.StorageCollection
}

func newXaddHandler(storage *storage.StorageCollection) *XaddHandler {
	return &XaddHandler{
		storage: storage,
	}
}

func (h *XaddHandler) minArgs() int {
	return 3
}

func (h *XaddHandler) processCmd(parsedResult []resp.ParsedCmd) []string {
	key, id := parsedResult[0].Value, parsedResult[1].Value
	entries := parsedResult[2:]

	storageValue, ok := h.storage.GetCurrentStorage().Get(key)
	var stream *storage.Stream

	if !ok {
		stream = storage.NewStream()
	} else {
		stream = storageValue.Value.(*storage.Stream)
	}

	// new or find, todo
	msTime, sqNumber, streamId, err := getParsedStreamId(id, stream)

	if err != nil {
		return []string{resp.HandleEncode(resp.RESP_ENCODING_CONSTANTS.ERROR, err.Error())}
	}
	streamEntry := storage.NewStreamEntry(msTime, sqNumber)

	for i := 0; i < len(entries); i += 2 {
		if i+1 >= len(entries) {
			break
		}
		key, value := entries[i].Value, entries[i+1].Value
		streamEntry.AddKeyValuePair(key, value)
	}

	stream.AddEntry(streamEntry)

	h.storage.SetItemToCurrentStorage(key, &storage.StorageItem{
		Type:  storage.STREAM,
		Value: stream,
	})

	return []string{resp.HandleEncode(resp.RESP_ENCODING_CONSTANTS.BULK_STRING, streamId)}
}

func getParsedStreamId(id string, stream *storage.Stream) (msTime, sqNumber int64, streamId string, err error) {
	msTime, sqNumber, err = getMsAndSqFromId(id, stream)

	if err != nil {
		return 0, 0, "", errStreamIdZero
	}

	if msTime == 0 && sqNumber == 0 {
		return 0, 0, "", errStreamIdZero
	}
	entries := stream.GetEntries()
	if len(entries) == 0 {
		return msTime, sqNumber, fmt.Sprintf("%d-%d", msTime, sqNumber), nil
	}

	lastEntry := entries[len(entries)-1]

	if lastEntry.MsTime > msTime || lastEntry.MsTime == msTime && lastEntry.SqNumber >= sqNumber {
		return 0, 0, "", errTooSmallStreamId
	}

	return msTime, sqNumber, fmt.Sprintf("%d-%d", msTime, sqNumber), nil
}

func getMsAndSqFromId(id string, stream *storage.Stream) (msTime, sqNumber int64, err error) {
	// autogeneration
	if id == "*" {
		msTime, err := getMsTime(id)
		if err != nil {
			return 0, 0, err
		}
		sqTime, err := getSqNumber(id, msTime, stream)
		if err != nil {
			return 0, 0, err
		}

		return msTime, sqTime, err
	}

	// explicit id

	split := strings.Split(id, "-")
	if len(split) != 2 {
		return 0, 0, errStreamIdFormat
	}

	msTime, err = getMsTime(split[0])
	if err != nil {
		return 0, 0, err
	}
	sqNumber, err = getSqNumber(split[1], msTime, stream)
	if err != nil {
		return 0, 0, err
	}

	return msTime, sqNumber, nil

}

func getAutoGeneratedSqNumber(msTime int64, entries []*storage.StreamEntry) int64 {
	var sqNumber int64

	if msTime == 0 {
		sqNumber = 1
	}

	for i := len(entries) - 1; i >= 0; i-- {
		if entries[i].MsTime == msTime {
			sqNumber = entries[i].SqNumber + 1
			break
		}
	}

	return sqNumber

}

func getSqNumber(sq string, msTime int64, stream *storage.Stream) (sqNumber int64, err error) {
	if sq == "*" {
		return getAutoGeneratedSqNumber(msTime, stream.GetEntries()), nil

	}
	// explicit
	sqNumber, err = strconv.ParseInt(sq, 10, 64)
	if err != nil {
		return 0, err
	}

	return sqNumber, nil
}

func getMsTime(msTimeStr string) (msTime int64, err error) {
	if msTimeStr == "*" {
		return time.Now().UnixMilli(), nil
	}

	// explicit
	msTime, err = strconv.ParseInt(msTimeStr, 10, 64)
	if err != nil {
		return 0, err
	}

	return msTime, nil
}
